<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on taka👨🏻‍💻</title><link>https://takakd.github.io/tags/golang/</link><description>Recent content in golang on taka👨🏻‍💻</description><generator>Hugo -- gohugo.io</generator><language>ja</language><copyright>&amp;copy; taka 2018</copyright><lastBuildDate>Fri, 23 Oct 2020 05:24:54 +0900</lastBuildDate><atom:link href="https://takakd.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>SlackのEventAPIのリトライコールを防ぐ - golang</title><link>https://takakd.github.io/articles/20201023052454/</link><pubDate>Fri, 23 Oct 2020 05:24:54 +0900</pubDate><guid>https://takakd.github.io/articles/20201023052454/</guid><description>エラーレスポンスを返す時でもリトライさせたくない場合は、ヘッダにX-Slack-No-Retryを指定する。 func handler(w http.ResponseWriter, r *http.Request) { // Process something... // Set &amp;#34;X-Slack-No-Retry: 1&amp;#34; if prevent retry. w.Header().Set(&amp;#34;X-Slack-No-Retry&amp;#34;, &amp;#34;1&amp;#34;) w.Header().Set(&amp;#34;Content-Type&amp;#34;, &amp;#34;application/json&amp;#34;) w.WriteHeader(http.StatusBadRequest) w.Write([]byte(&amp;#34;&amp;#34;)) } Reference https://api.slack.com/events-api#the-events-api__field-guide__error-handling__graceful-retries__turning-retries-off</description></item><item><title>generate gomockでエラーが出た - golang</title><link>https://takakd.github.io/articles/20201021052243/</link><pubDate>Wed, 21 Oct 2020 05:22:43 +0900</pubDate><guid>https://takakd.github.io/articles/20201021052243/</guid><description>gomockでエラー。とりあえず古いファイルを消して再実行すると解消できた。 % mockgen -source ./internal/app/usecase/xxx/repository.go -destination ./internal/app/usecase/xxx/repository_mock.go -package xxx -: found packages xxx (repository.go) and mock_updateproteinevent (repository_mock.go) in /Users/xxx/go/src/proteinreminder/internal/app/usecase/xxx 2020/10/21 04:21:56 Loading input failed: loading package failed # Delete % rm -rf ./internal/app/usecase/xxx/repository_mock.go # Run again and completed. % mockgen -source ./internal/app/usecase/xxx/repository.go -destination ./internal/app/usecase/xxx/repository_mock.go -package xxx</description></item><item><title>golang-migrateのヘルパスクリプト - golang</title><link>https://takakd.github.io/articles/20201017051917/</link><pubDate>Sat, 17 Oct 2020 05:19:17 +0900</pubDate><guid>https://takakd.github.io/articles/20201017051917/</guid><description>.sql向けgolang-migrateのヘルパスクリプトです。 機能 .envからデータソースを読み込み ディレクトリ内のSQLファイルでマイグレート SQLのみ対応 helper.sh #!/usr/bin/env bash # golang-migrate helper script # https://github.com/golang-migrate/migrate usage() { echo &amp;#34;Usage: migrate.sh COMMAND COMMAND: Input golang-migrate command and options. &amp;#39;create&amp;#39; is limited to SQL. e.g. migrate.sh create NAME migrate.sh up migrate.sh down 2 &amp;#34; } if [[ &amp;#34;$1&amp;#34; = &amp;#34;help&amp;#34; ]]; then usage exit 0 fi SCRIPT_DIR=$(cd $(dirname &amp;#34;$0&amp;#34;); pwd) ENV_FILE=${SCRIPT_DIR}/../configs/.env if [[ -e &amp;#34;$ENV_FILE&amp;#34; ]]; then source &amp;#34;$ENV_FILE&amp;#34; fi # Limit create to SQL if [[ &amp;#34;$1&amp;#34; = &amp;#34;create&amp;#34; ]]; then # Exclude options param=$(echo &amp;#34;$@&amp;#34; | sed -e &amp;#39;s/create //&amp;#39;) # Remove schema from env value dir=$(echo &amp;#34;$MIGRATION_DIR&amp;#34; | sed -e &amp;#39;s/file:\/\///&amp;#39;) migrate -source &amp;#34;$MIGRATION_DIR&amp;#34; -database &amp;#34;$DATABASE_URL&amp;#34; create -dir $dir -ext sql $param else migrate -source &amp;#34;$MIGRATION_DIR&amp;#34; -database &amp;#34;$DATABASE_URL&amp;#34; $@ fi .env MIGRATION_DIR=/Users/user/... DATABASE_URL=mysql:... プロジェクトに応じたヘルパスクリプトをよく作るのですが、他の現場ではどのくらい用意しているんだろう。</description></item><item><title>API Gateway + Lambda - golang</title><link>https://takakd.github.io/articles/20200705022238/</link><pubDate>Sun, 05 Jul 2020 02:22:39 +0900</pubDate><guid>https://takakd.github.io/articles/20200705022238/</guid><description>APIGateway + GoでLambdaのサンプルです。 仕様 エンドポイント: https://&amp;lt;API ID&amp;gt;.execute-api.ap-northeast-1.amazonaws.com/&amp;lt;stage&amp;gt;/&amp;lt;Resource&amp;gt; HTTPメソッド: GET パラメータ: { &amp;#34;text&amp;#34;: &amp;#34;string&amp;#34; } Lambdaハンドラ 引数をstructで定義。 package main import ( &amp;#34;context&amp;#34; &amp;#34;github.com/aws/aws-lambda-go/lambda&amp;#34; &amp;#34;github.com/pkg/errors&amp;#34; ) // Ref: https://docs.aws.amazon.com/lambda/latest/dg/golang-handler.html // Receive arguments as struct. type Event struct { Text string `json:&amp;#34;text&amp;#34;` } func (e *Event) validate() bool { valid := true if e.Text == &amp;#34;&amp;#34; { valid = false } return valid } // Response type Response struct { Message string `json:&amp;#34;message&amp;#34;` } // Lambda handler func HandleRequest(ctx context.Context, event Event) (Response, error) { resp := Response{} if !event.validate() { return resp, errors.Errorf(&amp;#34;need text.&amp;#34;) } // Something to do you want here. resp.Message = &amp;#34;ok&amp;#34; return resp, nil } // Main func main() { lambda.Start(HandleRequest) } 統合リクエスト - マッピングテンプレート structに設定する値を追加。 ここではtextを設定しています。 #set($allParams = $input.params()) { &amp;#34;text&amp;#34;: &amp;#34;$input.params(&amp;#39;text&amp;#39;)&amp;#34;, &amp;#34;body-json&amp;#34; : $input.json(&amp;#39;$&amp;#39;), ... } レスポンス 返ってくるレスポンス。 { &amp;#34;message&amp;#34;: &amp;#34;ok&amp;#34; }</description></item><item><title>安全なtruncate string - golang</title><link>https://takakd.github.io/articles/20200628021817/</link><pubDate>Sun, 28 Jun 2020 02:18:17 +0900</pubDate><guid>https://takakd.github.io/articles/20200628021817/</guid><description>package main import ( &amp;#34;fmt&amp;#34; ) // Truncate string. func TruncateString(str string, length int) string { if length &amp;lt;= 0 { return &amp;#34;&amp;#34; } // This code cannot support Japanese // orgLen := len(str) // if orgLen &amp;lt;= length { // return str // } // return str[:length] // Support Japanese // Ref: Range loops https://blog.golang.org/strings truncated := &amp;#34;&amp;#34; count := 0 for _, char := range str { truncated += string(char) count++ if count &amp;gt;= length { break } } return truncated } // Main func main() { dataList := [][]interface{} { {&amp;#34;drink&amp;#34;, 3, &amp;#34;dri&amp;#34;}, {&amp;#34;drink&amp;#34;, 6, &amp;#34;drink&amp;#34;}, {&amp;#34;drink&amp;#34;, 0, &amp;#34;&amp;#34;}, {&amp;#34;drink&amp;#34;, -1, &amp;#34;&amp;#34;}, {&amp;#34;drink&amp;#34;, 100, &amp;#34;drink&amp;#34;}, {&amp;#34;pub&amp;#34;, 100, &amp;#34;pub&amp;#34;}, {&amp;#34;こんにちは&amp;#34;, 3, &amp;#34;こんに&amp;#34;}, } for _, dl := range dataList { r := TruncateString(dl[0].(string), dl[1].(int)) if r != dl[2].(string) { fmt.Printf(&amp;#34;ERROR: got=%s, want=%s&amp;#34;, r, dl[2].(string)) } } } https://play.golang.org/p/iakC8xxTlFI Reference: https://play.golang.org/p/EzvhWMljku 次のコードはエラーが出る。 package main import ( &amp;#34;fmt&amp;#34; ) func main() { s := &amp;#34;drink&amp;#34; r := s[:20] // error fmt.Println(r) } https://play.golang.org/p/7IfclYXADoW</description></item><item><title>"omitempty"のメモ - golang</title><link>https://takakd.github.io/articles/20200625021433/</link><pubDate>Thu, 25 Jun 2020 02:14:34 +0900</pubDate><guid>https://takakd.github.io/articles/20200625021433/</guid><description>json.Marshal はomitemptyが値型stringに設定されていれば空文字を出力する。 フィールド自体不要な場合は、ポインタ型stringにするといい。 package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; ) type ValueSlice struct { Values []V `json:&amp;#34;b,omitempty&amp;#34;` } type PtrSlice struct { Values []*V `json:&amp;#34;b,omitempty&amp;#34;` } type ValueStruct struct { Value V `json:&amp;#34;value,omitempty&amp;#34;` } type PtrStruct struct { Value *V `json:&amp;#34;value,omitempty&amp;#34;` } type V struct { Value string `json:&amp;#34;value&amp;#34;` } func main() { v1 := &amp;amp;ValueSlice{} v2 := &amp;amp;PtrSlice{} v3 := &amp;amp;ValueStruct{} v4 := &amp;amp;PtrStruct{} bv1, _ := json.Marshal(v1) bv2, _ := json.Marshal(v2) bv3, _ := json.Marshal(v3) bv4, _ := json.Marshal(v4) fmt.Printf(&amp;#34;bv1: %v\n&amp;#34;, string(bv1)) fmt.Printf(&amp;#34;bv2: %v\n&amp;#34;, string(bv2)) fmt.Printf(&amp;#34;bv3: %v\n&amp;#34;, string(bv3)) fmt.Printf(&amp;#34;bv4: %v\n&amp;#34;, string(bv4)) } 出力結果 bv1: {} bv2: {} bv3: {&amp;#34;value&amp;#34;:{&amp;#34;value&amp;#34;:&amp;#34;&amp;#34;}} bv4: {} https://play.golang.org/p/7XKphsEayCN</description></item><item><title>ParseFormした値をstructに設定 - golang</title><link>https://takakd.github.io/articles/20200623021217/</link><pubDate>Tue, 23 Jun 2020 02:12:17 +0900</pubDate><guid>https://takakd.github.io/articles/20200623021217/</guid><description>// Set FormValues to struct func SetFormValueToStruct(values url.Values, structPtr interface{}) error { // Get the pointer of struct ptr := reflect.ValueOf(structPtr) // Get the value of struct value := ptr.Elem() // Set value to struct field valueType := value.Type() for i := 0; i &amp;lt; value.NumField(); i++ { jsonTag := valueType.Field(i).Tag.Get(&amp;#34;json&amp;#34;) if value.Field(i).CanSet() == false { return errors.New(&amp;#34;cannot set value to field&amp;#34;) } value.Field(i).Set(reflect.ValueOf(values.Get(jsonTag))) } return nil } // Example func ExampleSetFormValueToStruct() { // Form values formValues := url.Values{} formValues.Set(&amp;#34;test1&amp;#34;, &amp;#34;test1_value&amp;#34;) formValues.Set(&amp;#34;test2&amp;#34;, &amp;#34;test2_value&amp;#34;) // Struct that be wanted to set form values. structPtr := &amp;amp;TestSetFormValueToStructStruct{} // Set structWithValuesPtr := apphttputil.SetFormValueToStruct(formValues, structPtr) fmt.Printf(&amp;#34;%v&amp;#34;, structWithValuesPtr) }</description></item><item><title>URLクエリ文字列を生成 - golang</title><link>https://takakd.github.io/articles/20200620021106/</link><pubDate>Sat, 20 Jun 2020 02:11:07 +0900</pubDate><guid>https://takakd.github.io/articles/20200620021106/</guid><description>params := url.Values{ &amp;#34;keyword&amp;#34;: {&amp;#34;some&amp;#34;}, } reqUrl := &amp;#34;https://yourendpoint.example.com?&amp;#34; + params.Encode() Reference https://golang.org/pkg/net/url/#URL.Query</description></item><item><title>ユニコードキャラクタをエスケープシーケンスに変換 - golang</title><link>https://takakd.github.io/articles/20200612020628/</link><pubDate>Fri, 12 Jun 2020 02:06:28 +0900</pubDate><guid>https://takakd.github.io/articles/20200612020628/</guid><description>json.Unmarshalしたデータに含まれる文字列のユニコードキャラクタをエスケープシーケンスに変換します。 // func convertJsonElement(data interface{}) interface{} { switch v := data.(type) { case map[string]interface{}: for ik, iv := range v { v[ik] = convertJsonElement(iv) } data = v case []interface{}: for ik, iv := range v { v[ik] = convertJsonElement(iv) } data = v case string: v = fmt.Sprintf(&amp;#34;%+q&amp;#34;, v) if len(v) &amp;gt; 0 { // Remove unnecessary double-quote data = v[1 : len(v)-1] } default: } return data } // func main() { jsonStr := []byte(`{&amp;#34;test&amp;#34;:&amp;#34;こんにちは&amp;#34;}`) var data interface{} json.Unmarshal(jsonStr, &amp;amp;data) convertedData := convertJsonElement(data) }</description></item><item><title>パッケージ名で悩む - golang</title><link>https://takakd.github.io/articles/20200607143024/</link><pubDate>Sun, 07 Jun 2020 14:30:24 +0900</pubDate><guid>https://takakd.github.io/articles/20200607143024/</guid><description>プロジェクト内で、HTTPのユーティリティ関数をまとめるモジュールの命名に悩んでいました。 結果はproject-layoutの構成で、internalの下にhttputilを配置して解決。 悩んでいた時は回答がでず、こちらで聞いてみると、 internalを作って、その下は好きにするといい httpextとextをつける というような意見をいただきました。 個人的にはinternalを使うほうが、プロジェクト内ということがわかりやすいと考え、そちらで実装。 最初に考えていた名前は、mypackage/utils しかし、&amp;ldquo;Avoid meaningless package names.&amp;rdquo; (&amp;ldquo;Bad package names&amp;rdquo; section). という記載があるので違う気がする。 次は、mypackage/http or mypackage/httputil これは、&amp;ldquo;Avoid unnecessary package name collisions.&amp;rdquo; (&amp;ldquo;Bad package names&amp;rdquo; section). にひっかかるので違う気がする。 最後に、mypackage/apphttputilsにしてましたが、どうにも冗長。質問を投げてみて、</description></item><item><title>panicのテスト - golang</title><link>https://takakd.github.io/articles/20200528043646/</link><pubDate>Thu, 28 May 2020 04:36:46 +0900</pubDate><guid>https://takakd.github.io/articles/20200528043646/</guid><description>Goでパニックが発生するかどうかのテストです。 // Testing if testFunc calls panic. // e.g. // IsTestCallPanic(func(){ // &amp;lt;place test target here.&amp;gt; // }) func IsTestCallPanic(testFunc func()) (ok bool) { defer func() { if err := recover(); err == nil { ok = false } }() ok = true testFunc() return } // Test for test. func TestIsTestCallPanic(t *testing.T) { isCalled := IsTestCallPanic(func() { var i interface{} if i == nil { panic(&amp;#34;Hi, panic.&amp;#34;) } }) if !isCalled { t.Errorf(&amp;#34;failed.&amp;#34;) } }</description></item><item><title>Interfaceポインタの型エラー - golang</title><link>https://takakd.github.io/articles/20200413235004/</link><pubDate>Mon, 13 Apr 2020 23:50:06 +0900</pubDate><guid>https://takakd.github.io/articles/20200413235004/</guid><description>Iocコンテナを作ろうとして次のようなコードを書くとエラーが出ました。 原因はinterfaceのポインタの型エラー。 // interface type IFace interface { hello() string } // concrete type type Concrete struct { } func NewConcrete() *Concrete { return &amp;amp;Concrete{} } // - implementation func (c *Concrete) hello() string { return &amp;#34;Hi&amp;#34; } // ioc type Ioc struct { } func NewIoc() *Ioc { return &amp;amp;Ioc{} } // NG: this method raises error // これは次のようなエラーがでる // cannot use NewConcrete() (type *Concrete) as type *IFace in return argument: // *IFace is pointer to interface, not interface func (i *Ioc) IFace() *IFace { return NewConcrete() } // こちらはOK func (i *Ioc) IFace() IFace { return NewConcrete() } func main() { i := NewIoc() ic := i.IFace() // ... } いくつ書き換えるとOK。 しかし綺麗ではない。 // value receiverにする func (c Concrete) hello() string { return &amp;#34;Hi&amp;#34; } ... // 型を明示的に指定していれるとOK func (i *Ioc) IFace() *IFace { var vif IFace var pif *IFace vif = *NewConcrete() pif = &amp;amp;vif return pif } structと同様に、ポインタを返したほうがコピーされる時のコストが低くなるかと思いきや、そもそもinterfaceはポインタ2個分なのでそれほどコストがかからない。 https://groups.google.com/forum/#!topic/golang-nuts/N9f70MZUulk ちゃんとA Tour Of Goにも書いてますね…… https://tour.golang.org/methods/11 参考 https://groups.google.com/forum/#!topic/golang-nuts/N9f70MZUulk https://play.golang.org/p/5YquxHKRWL</description></item><item><title>error table [name] has no column [column]</title><link>https://takakd.github.io/articles/20200131021820/</link><pubDate>Fri, 31 Jan 2020 02:18:21 +0900</pubDate><guid>https://takakd.github.io/articles/20200131021820/</guid><description>GoでsqliteにデータをInsertしようとしてエラー。 $ error table Balance has no column named price Insertしているコードを見ても問題はない。 カラムを確認すると…… 2個目のカラムがおかしい。 $ sqlite3 ./some_db_file_name.sql $ PRAGMA table_info(Balance); 0|time|DATETIME|1||1 1|rate|FLOAT|0||0 2|half|FLOAT price FLOAT|0||0 3|total|FLOAT|0||0 CREATE TABLEを確認するとtypoでした。 c := fmt.Sprintf(` CREATE TABLE IF NOT EXISTS %s ( time DATETIME PRIMARY KEY NOT NULL, rate FLOAT, half FLOAT price FLOAT, total FLOAT)`, Balance) DbConnection.Exec(c)</description></item></channel></rss>