<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AIZU ONLINE JUDGE on taka👨🏻‍💻</title>
    <link>https://takakd.github.io/tags/aizu-online-judge/</link>
    <description>Recent content in AIZU ONLINE JUDGE on taka👨🏻‍💻</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>&amp;copy; taka 2018</copyright>
    <lastBuildDate>Sat, 07 Mar 2020 20:01:02 +0900</lastBuildDate><atom:link href="https://takakd.github.io/tags/aizu-online-judge/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Reconstruction of a Tree</title>
      <link>https://takakd.github.io/articles/20200307195400/</link>
      <pubDate>Sat, 07 Mar 2020 20:01:02 +0900</pubDate>
      
      <guid>https://takakd.github.io/articles/20200307195400/</guid>
      <description>Reconstruction of a Tree Preorderだけだと構造が決まらないので、Inorderと合わせて木構造を決定する。 Inorderの値の中のPreorder値の左右が、木の左右に対応する。 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;strings&amp;quot; ) func scanInput() (n int, pre []int, in []int) { fmt.Scanf(&amp;quot;%d&amp;quot;, &amp;amp;n) pre = make([]int, n) in = make([]int, n) for i := 0; i &amp;lt; n; i++ { fmt.Scanf(&amp;quot;%d&amp;quot;, &amp;amp;pre[i]) } for i := 0; i &amp;lt; n; i++ { fmt.Scanf(&amp;quot;%d&amp;quot;, &amp;amp;in[i]) } return } func printSlice(slice []int) { fmt.Println(strings.Trim(strings.Join(strings.Fields(fmt.Sprint(slice)), &amp;quot; &amp;quot;), &amp;quot;[]&amp;quot;)) } func main() { n, pre, in := scanInput() post := make([]int, 0, n) parent := 0 walk(0, len(pre)-1, &amp;amp;parent, pre, in, &amp;amp;post) printSlice(post) } func walk(left, right int, parent *int, pre, in []int, post *[]int) { if left &amp;gt; right { return } dlm := pre[*parent] *parent++ var idx int for i, v := range in { if v == dlm { idx = i break } } walk(left, idx-1, parent, pre, in, post) walk(idx+1, right, parent, pre, in, post) *post = append(*post, dlm) } 配列の結果をポインタで引き回しているけど、引数で返したほうがよいのかな。 参考 https://stackoverflow.com/questions/8307478/how-to-find-out-element-position-in-slice</description>
    </item>
    
    <item>
      <title>Insertion Sort</title>
      <link>https://takakd.github.io/articles/20200306012400/</link>
      <pubDate>Sat, 07 Mar 2020 01:24:02 +0900</pubDate>
      
      <guid>https://takakd.github.io/articles/20200306012400/</guid>
      <description>もう一回おさらいということで プログラミングコンテスト攻略のためのアルゴリズムとデータ構造を購入しました。 AIZU ONLINE JUDGEのInsertion Sortです。 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;strings&amp;quot; ) func scanInput() (n int, slice []int) { fmt.Scanf(&amp;quot;%d&amp;quot;, &amp;amp;n) slice = make([]int, n) for i := 0; i &amp;lt; n; i++ { fmt.Scanf(&amp;quot;%d&amp;quot;, &amp;amp;slice[i]) } return } func printSlice(slice []int) { fmt.Println(strings.Trim(strings.Join(strings.Fields(fmt.Sprint(slice)), &amp;quot; &amp;quot;), &amp;quot;[]&amp;quot;)) } func main() { _, slice := scanInput() printSlice(slice) solve(slice) } func solve(nums []int) { l := len(nums) for i := 1; i &amp;lt; l; i++ { v := nums[i] j := i - 1 for j &amp;gt;= 0 &amp;amp;&amp;amp; nums[j] &amp;gt; v { nums[j+1] = nums[j] j-- } nums[j+1] = v printSlice(nums) } } ロジックよりも、入力を受け取る実装で戸惑いました。 プログラミングパズルは言語の筋トレにもなっていいですね。 参考 https://stackoverflow.com/questions/37532255/one-liner-to-transform-int-into-string</description>
    </item>
    
  </channel>
</rss>
